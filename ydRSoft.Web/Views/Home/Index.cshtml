@using ydRSoft.Modelo
@model UsuarioModel

@{
    ViewBag.Title = "Smart Kitchen";

    UsuarioModel mUser = new UsuarioModel();
    if (Model != null)
    {
        mUser = Model;
    }
}

<div class="texto-Arriba-Der" id="vistaMenu" hidden>
    <div class="contenido-ydR">
        <div class="menu-superior">
            <strong> <i class="fa fa-shopping-cart"></i> PRODUCTOS  </strong>
        </div>
        <div class="menu-inferior">
            <div id="vistaProd">
            </div>
        </div>
    </div>
</div>
<input id="nomydR" value="Bienvenido a SmartKitchen. @mUser.Nombres" hidden />
<input id="nomInydRc" value="@mUser.Nombres.ToUpper()" hidden/>
<input id="IdInydRc" value="@mUser.Id" hidden />
<div class="row">
    <div class="col-md-3">
        <div class="ydRNombres text-success">
            <div class="row">
                <div class="col-md-2">
                    @if (mUser.IdSexo == ydRSoft.Util.Variables.MUJER)
                    {
                        <div>
                            <img class="img-circle" width="40" src="~/Content/Imagenes/Avatar/mujer.png" />
                        </div>
                    }
                    else
                    {
                        <div>
                            <img class="img-circle" height="40" src="~/Content/Imagenes/Avatar/hombre.png" />
                        </div>
                    }
                </div>
                <div class="col-md-10" id="idLoad1">
                    Bienvenido : @mUser.Nombres.ToUpper()
                </div>
            </div>

        </div>
        <div id="viewReceta"> </div>
    </div>
    <div class="col-md-9">
        <canvas id="canvasCorona"></canvas>
    </div>
</div>

<div id="viewPaginas"></div>

<div class="modal inmodal fade" id="modalCamara" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <button class="btn btn-circle btn-danger float-right" data-dismiss="modal"><i class="fa fa-close"></i></button>

        <video id="video" autoplay style="object-fit: contain; width: 100%; height: auto;"></video>
        <canvas id="canvas" width="1280" height="720" style="display: none;"></canvas>
    </div>
</div>

@Html.Partial("_verComandos")

@Html.Partial("~/Areas/AReceta/Views/Receta/_verCategorias.cshtml")


<script>
    function vozBienvenida() {
        var txtletra = document.getElementById("nomydR").value
        hablarTexto(txtletra);
    }
</script>


<script id="_Ajustar_Camara_">
    navigator.mediaDevices.getUserMedia({
        video: {
            width: { ideal: 1280 },
            height: { ideal: 720 }
        }
    }).then(function (stream) {
        const video = document.getElementById('video');
        video.srcObject = stream;
        video.onloadedmetadata = function () {
            // Ajusta el tamaño del video según la resolución de la cámara
            video.play();
        };
    }).catch(function (err) {
        console.error("Error al acceder a la cámara: " + err);
    });
</script>

<script id="_Captura_de_camara">

    (function () {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const startCaptureButton = document.getElementById('startCapture');
        let isCapturing = false;
        let isSending = false; // Bandera para controlar el envío de la imagen
        let captureInterval;

        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                video.srcObject = stream;
            })
            .catch(err => {
                alert("No se puede acceder a la cámara. Por favor, verifica que esté conectada.");
            });

        // Llamar a la función globalmente
        window.IniciarCaptura = IniciarCaptura;

        function IniciarCaptura() {
            if (!isCapturing) {
                isCapturing = true;

                startCaptureButton.classList.remove('btn-success');
                startCaptureButton.classList.add('btn-primary');
                // Iniciar la captura cada 2 segundos
                captureInterval = setInterval(() => {
                    if (!isSending) {
                        //captureAndSendImage();
                        EnviarImagen();
                    }
                }, 3000);
            } else {
                isCapturing = false;
                startCaptureButton.classList.remove('btn-primary');
                startCaptureButton.classList.add('btn-success');

                // Detener el intervalo de captura
                clearInterval(captureInterval);
            }
        }

        async function EnviarImagen() {
            // Configurar el canvas solo cuando la cámara esté disponible
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = canvas.toDataURL('image/png'); // Base64

                isSending = true; // Marcar como enviando

                // Medir el tiempo de inicio
                const startTime = performance.now();

                try {
                    // Enviar la imagen al servidor
                    //ConsultarApi
                    const response = await fetch('/AProducto/Producto/Prueba', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ image64: imageData })
                    });

                    if (!response.ok) {
                        throw new Error('Error en la respuesta del servidor');
                    }

                    const data = await response.json();
                    console.log('Imagen enviada con éxito:', data);

                    dibujarProd(data);
                    MostrarMenu(data);

                } catch (error) {
                    console.error('Error al enviar la imagen:', error);
                } finally {
                    isSending = false; // Liberar la bandera al terminar
                    const endTime = performance.now();
                    const elapsedTime = endTime - startTime;
                    console.log(`Tiempo de ejecución: ${elapsedTime.toFixed(2)} ms`);
                }
            }
        }

    })();

</script>

<script id="_fun_recetas">

    async function funRecetas() {
        $("#viewPaginas").html("");
        document.getElementById("idLoad1").innerHTML = "<i class='fa fa-spinner'> Cargando Recetas ...</i>";
        document.getElementById("btnReceta").disabled = true;

        const response = await fetch('/AReceta/Receta/ObtenerRecetas', {
            method: 'POST',
        });

        if (response.ok) {
            const data = await response.text();
            $("#viewPaginas").html(data);
        } else {
            divResult.innerHTML = '<h3> Ninguna receta Disponible </h3>';
        }

        document.getElementById("idLoad1").innerHTML = "Bienvenido : " + ydR1bNom;
        document.getElementById("btnReceta").disabled = false;
    }

</script>


<script>
    function dibujarCirculo() {
        var canvas = document.getElementById('canvasCorona');
        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            //ctx.clearRect(0, 0, canvas.width, canvas.height);  // Limpiar el canvas

            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 5;  // Ancho del borde
            ctx.strokeRect(0, 75, 1420, 995);  //rectangulo

            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 70, 60, 60);

            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 70, 10, 995);

            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 70, 1420, 10);

        }
    }


</script>

<script id="_Dibujar_Corona_">
    // Obtener el canvas y el contexto
    const canvas = document.getElementById('canvasCorona');
    const ctx = canvas.getContext('2d');
    const anchoCorona = 50;
    const Tipoletra = '"Lucida Console"';
    const letraInfo = '"Segoe UI"';
    const tamNombre = 30;
    const tamInfo = 20;
    const tamInfoN = 24;
    const tamInfoV = 32;
    const CantInfo = 5;
    // Ajustar el tamaño del canvas al tamaño de la ventana
    function ajustarCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //dibujarCirculo();

    }
    async function dibujarProd(productos) {
        try {

            // Limpiar el canvas solo una vez antes de dibujar todos los productos
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            productos.forEach(producto => {
                mostrarProductos(producto); // Llamar a la función mostrarData para cada producto
            });

        } catch (error) {
            console.error(error);
        }

    }

    function MostrarMenu(productos) {

        const vistaMenu = document.getElementById("vistaProd");
        vistaMenu.innerHTML = ""; // Limpiar contenido previo

        // Iterar sobre la lista de productos y mostrarlos
        productos.forEach((producto, index) => {

            vistaMenu.innerHTML += `<div> <i class="fa fa-hand-o-right texto-icon-VerdeF"></i> ${producto.Id} ${producto.Nombre}</div>`;
        });
    }

    function mostrarProductos(producto) {

        let nombre = producto.Nombre;
        let posX = producto.PosX;
        let posY = producto.PosY;
        let radio = producto.Radio;

        let listaValor = [];
        listaValor.push(producto.Info.Calorias);
        listaValor.push(producto.Info.Proteinas);
        listaValor.push(producto.Info.Fibra);
        listaValor.push(producto.Info.Azucares);
        listaValor.push(producto.Info.Sodio);
        listaValor.push(producto.Info.Colesterol);

        dibujarCorona(posX, posY, radio);
        dibujarInfo(posX, posY, radio);
        dibujarNombre(posX, posY, radio, nombre);
        dibujarLinea(posX, posY, radio, listaValor);
    }

    // Dibujar la corona
    function dibujarCorona(x, y, radioExterior) {
        const radioInterior = radioExterior - anchoCorona;

        // Dibujar círculo exterior
        ctx.beginPath();
        ctx.arc(x, y, radioExterior, 0, Math.PI * 2, false);
        ctx.fillStyle = 'rgb(64, 150, 84)';
        ctx.fill();

        // Dibujar círculo interior (eliminar el centro)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, radioInterior, 0, Math.PI * 2, false);
        ctx.fill();

        // Restaurar el modo de dibujo
        ctx.globalCompositeOperation = 'source-over';

    }

    function dibujarNombre(x, y, radioExterior, texto) {

        const radioInterior = radioExterior - anchoCorona;
        // Configuración de la fuente
        ctx.font = `${tamNombre}px ${Tipoletra}`;

        ctx.fillStyle = 'white'; // Color del texto

        const anguloInicio = 1; // Comienza desde el lado izquierdo de la corona
        const anguloPaso = 0.25 * 100 / radioExterior; // Ángulo entre cada letra

        // Ajustar el radio donde se dibuja el texto
        const radioTexto = radioInterior + 35; // Ajustar el radio para el texto

        const index = texto.length - 1;
        let aux = 0;
        // Dibujar texto a lo largo de la curva en forma de "U"
        for (let i = index; i >= 0; i--) {
            const angulo = anguloInicio + aux * anguloPaso; // Ángulo para cada letra
            const letraX = x + (radioTexto * Math.cos(angulo)); // Coordenada x
            const letraY = y + (radioTexto * Math.sin(angulo)); // Coordenada y

            // Rotar el texto para que siga la curva
            ctx.save();
            ctx.translate(letraX, letraY);
            ctx.rotate(angulo + 4.65); // Alinea el texto hacia arriba
            ctx.fillText(texto[i], 0, 0); // Dibujar letra
            ctx.restore();
            aux++;
        }
    }

    function dibujarInfo(x, y, radioExterior) {
        const texto = "Tamaño de porcion 100g";
        const radioInterior = radioExterior - anchoCorona;
        // Configuración de la fuente
        ctx.font = `${tamInfo}px ${Tipoletra}`;
        ctx.fillStyle = 'white'; // Color del texto

        const anguloInicio = 5 // Comienza desde el lado izquierdo de la corona
        const anguloPaso = 0.13 * 100 / radioExterior;

        // Ajustar el radio donde se dibuja el texto
        const radioTexto = radioInterior + 20; // Ajustar el radio para el texto

        const index = texto.length - 1;
        // Dibujar texto a lo largo de la curva en forma de "U"
        let aux = 0;
        for (let i = index; i >= 0; i--) {
            const angulo = anguloInicio - aux * anguloPaso; // Ángulo para cada letra
            const letraX = x + (radioTexto * Math.cos(angulo)); // Coordenada x
            const letraY = y + (radioTexto * Math.sin(angulo)); // Coordenada y
            //alert("texto -> " + texto[i] + " Angulo -> " + angulo);
            // Rotar el texto para que siga la curva
            ctx.save();
            ctx.translate(letraX, letraY);
            ctx.rotate(angulo + Math.PI / 2); // Alinea el texto hacia arriba
            ctx.fillText(texto[i], 0, 0); // Dibujar letra
            ctx.restore();
            aux++;
        }
    }

    function dibujarLinea(x, y, radius, listValor) {
        const centerX = x;
        const centerY = y;
        const anguloInicio = 5.4;
        const anguloPaso = 0.39;

        const listaInfo = ["Calorias", "Proteinas", "Fibra", "Azucares", "Sodio", "Colesterol"]

        for (let i = 0; i < CantInfo; i++) {
            ctx.fillStyle = 'yellow';
            const angle = anguloInicio + i * anguloPaso; // Calcula el ángulo para cada rayo

            // Coordenadas del extremo de cada rayo en el borde
            const x1 = centerX + (radius - 10) * Math.cos(angle);
            const y1 = centerY + (radius - 10) * Math.sin(angle);

            // Coordenadas del extremo del rayo hacia afuera
            const x2 = centerX + (radius + 20) * Math.cos(angle); // Aumenta la longitud del rayo
            const y2 = centerY + (radius + 20) * Math.sin(angle);

            // Dibuja el rayo
            ctx.beginPath();
            ctx.moveTo(x1, y1); // Empieza desde el borde
            ctx.lineTo(x2, y2); // Finaliza más allá del borde
            ctx.lineWidth = 3; // Grosor de la línea
            ctx.strokeStyle = 'yellow'; // Color de la línea
            ctx.stroke();

            // Dibuja los círculos en ambos extremos
            ctx.beginPath();
            ctx.arc(x1, y1, 4, 0, Math.PI * 2); // Círculo en el borde
            ctx.fill();

            ctx.beginPath();
            ctx.arc(x2, y2, 3, 0, Math.PI * 2); // Círculo en el extremo
            ctx.fill();


            const textoValor = listValor[i];
            const textoNombre = listaInfo[i];

            // texto cantidad Valor
            ctx.fillStyle = 'white';
            ctx.font = `bold ${tamInfoV}px ${letraInfo}`;
            ctx.fillText(textoValor, x2 + 10, y2);

            // Texto nombre valor
            ctx.fillStyle = 'gray';
            ctx.font = `bold ${tamInfoN}px ${letraInfo}`;
            ctx.fillText(textoNombre, x2 + 10, y2 + 25);
        }
    }

    window.addEventListener('load', ajustarCanvas);
    window.addEventListener('resize', ajustarCanvas);
</script>
